<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Lambda on Vishnu Prasad</title>
    <link>https://vishnuprasad.blog/tags/lambda/</link>
    <description>Recent content in Lambda on Vishnu Prasad</description>
    <image>
      <title>Vishnu Prasad</title>
      <url>https://vishnuprasad.blog/papermod-cover.png</url>
      <link>https://vishnuprasad.blog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 23 Dec 2025 18:30:00 +0000</lastBuildDate>
    <atom:link href="https://vishnuprasad.blog/tags/lambda/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Building a Robust Error Handling System for AWS AppSync APIs with Appsync JS Resolvers</title>
      <link>https://vishnuprasad.blog/posts/appsync-error-handling/</link>
      <pubDate>Tue, 23 Dec 2025 18:30:00 +0000</pubDate>
      <guid>https://vishnuprasad.blog/posts/appsync-error-handling/</guid>
      <description>Introduction If you&amp;rsquo;ve built REST APIs with AWS API Gateway, you know how nice it is to return structured error responses with proper HTTP status codes, error types, and detailed context. Then you switch to GraphQL with AppSync, and suddenly your beautiful error handling becomes&amp;hellip; generic.
{ &amp;#34;errors&amp;#34;: [{ &amp;#34;message&amp;#34;: &amp;#34;Error&amp;#34; }] } That&amp;rsquo;s it. No error types. No structured context. Just a string.
This doesn&amp;rsquo;t have to be the case.</description>
    </item>
    <item>
      <title>How to Run AWS Lambda every 10 sec</title>
      <link>https://vishnuprasad.blog/posts/how-to-run-aws-lambda-every-10-sec/</link>
      <pubDate>Sat, 18 Feb 2023 18:30:00 +0000</pubDate>
      <guid>https://vishnuprasad.blog/posts/how-to-run-aws-lambda-every-10-sec/</guid>
      <description>Recently I had a requirement at work to run a cron job every 10 sec or 30 sec to poll some third-party API to pull some data. There will be more than 40 of these cron parallelly to fetch different sets of data from different APIs. The first obvious option would come to a serverless first mindset which I have is to run these on lambda functions.
The only native way in AWS to run the Lambda function is to have an Event bridge trigger with Cron expressions.</description>
    </item>
  </channel>
</rss>
